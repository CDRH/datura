from pathlib import Path
import json
from omeka_s_tools.api import OmekaAPIClient
import math
import yaml
import argparse

#needed for debugging purposes
import traceback
import os

# custom methods

def get_dir(relative_path):
    cwd = Path.cwd()
    return (cwd / relative_path).resolve()

def get_config(path, env='default'):
    with open(path) as stream:
        try:
            contents = yaml.safe_load(stream)
            return(contents[env])
        except yaml.YAMLError as exc:
            print(exc)

def reset():
    omeka = OmekaAPIClient(config['omeka_server'])
    omeka_auth = OmekaAPIClient(
        api_url = config['omeka_server'],
        key_identity = config['key_identity'],                        
        key_credential = config['key_credential']                        
    )

def item_sets():
    pages = math.ceil(omeka.get_resources("item_sets")["total_results"] / 5)
    item_sets = []
    for i in range(pages):
        item_sets += omeka.get_resources("item_sets", page=i)["results"]
    return item_sets

def get_item_set():
    env = get_environment()
    match env:
        case "production":
            item_set = prod_config["item_set"]
        case "development":
            item_set = dev_config["item_set"]
    return item_set

def get_environment():

    environment = args.environment
    return environment

def add_media_to_item(item_id, media_file, payload={}, template_id=None, class_id=None):
    # copied from the module to modify with different ingester
    '''
    Upload a media file and associate it with an existing item.

    Parameters:
    * `item_id` - the Omeka id of the item this media file should be added to
    * `media_path` - a path to an image/media file (string or pathlib Path)
    * `payload` (optional) - metadata to attach to media object, either
        a dict generated by `prepare_item_payload()` or `prepare_item_payload_using_template()`,
        or a string which is used as the value for `dcterms:title`.
    * `template_id` - internal Omeka identifier of a resource template you want to attach to this item
    * `class_id` - internal Omeka identifier of a resource class you want to attach to this item

    Returns:
    * a dict providing a JSON-LD representation of the new media object
    '''
    files = {}
    # For backwards compatibility
    if isinstance(media_file, dict):
        path = media_file['path']
        payload = media_file['title']
    # Make sure path is a Path object
    path = Path(media_file)
    if isinstance(payload, str):
        payload = omeka.omeka_auth.prepare_item_payload({'dcterms:title': [payload]})
    if template_id:
        payload['o:resource_template'] = omeka.omeka_auth.format_resource_id(template_id, 'resource_templates')
        if not class_id:
            template = omeka.omeka_auth.get_resource_by_id(template_id, 'resource_templates')
            class_id = template['o:resource_class']['o:id']
    if class_id:
        payload['o:resource_class'] = omeka.omeka_auth.format_resource_id(class_id, 'resource_classes')
    #add option to change ingester
    ingester = payload["o:ingester"] if payload["o:ingester"] else "upload"
    file_data = {
        'o:ingester': ingester,
        'file_index': '0',
        'o:source': path.name,
        'o:item': {'o:id': item_id},
    }
    payload.update(file_data)
    files[f'file[0]'] = path.read_bytes()
    files['data'] = (None, json.dumps(payload), 'application/json')
    response = omeka_auth.s.post(f'{omeka_auth.api_url}/media', files=files, params=omeka_auth.params)
    data = omeka_auth.process_response(response)
    return data

def prepare_item_payload_using_template(terms, template_id):
    '''
    Prepare an item payload, checking the supplied terms and values against the specified template.
    Note:
    * terms that are not in the template will generate a warning and be dropped from the payload
    * data types that don't match the template definitions will generate a warning and the term will be dropped from the payload
    * if no data type is supplied, a type that conforms with the template definition will be used

    Parameters:
    * `terms`: a dict of terms, values, and (optionally) data types
    * `template_id`: Omeka's internal numeric identifier for the template

    Returns:
    * the payload dict
    '''
    template_properties = omeka_auth.get_template_properties(template_id)
    payload = {}
    for term, values in terms.items():
        if term in template_properties:
            property_details = template_properties[term]
            payload[term] = []
            for value in values:
                if not isinstance(value, dict):
                    value = {'value': value}
                # The supplied data type doesn't match the template
                if 'type' in value and value['type'] not in property_details['type']:
                    print(f'Data type "{value["type"]}" for term "{term}" not allowed by template')
                    break
                elif 'type' not in value:
                    # Use default datatype from template if none is supplied
                    if len(property_details['type']) == 1:
                        value['type'] = property_details['type'][0]
                    # Use literal if allowed by template and data type not supplied
                    elif 'literal' in property_details['type']:
                        value['type'] = 'literal'
                    # Don't know what data type to use
                    else:
                        print(f'Specify data type for term "{term}"')
                        break
                if "property_id" in value:
                    #don't format values that have already been formatted
                    payload[term].append(value)
                else:
                    # Add a value formatted according to the data type
                    payload[term].append(omeka_auth.prepare_property_value(value, property_details['property_id']))
        # The supplied term is not in the template
        else:
            print(f'Term {term} not in template')
    return payload

def prepare_property_value(value, property_id, label = ""):
    '''
    Formats a property value according to its datatype as expected by Omeka.
    The formatted value can be used in a payload to create a new item.

    Parameters:
    * `value` - a dict containing a `value` and (optionally) a `type`
    * `property_id` - the numeric identifier of the property
    * `label` - a text label for the URI if `type` is "uri"

    Note that is no `type` is supplied, 'literal' will be used by default.

    Returns:
    * a dict with values for `property_id`, `type`, and either `@id` or `@value`.
    '''
    if not isinstance(value, dict):
        value = {'value': value}

    try:
        data_type = value['type']
    except KeyError:
        data_type = 'literal'

    property_value = {
        'property_id': property_id,
        'type': data_type
    }

    if data_type == 'resource:item':
        property_value['@id'] = f'{self.api_url}/items/{value["value"]}'
        property_value['value_resource_id'] = value['value']
        property_value['value_resource_name'] = 'items'
    elif data_type == 'uri':
        property_value['@id'] = value['value']
        property_value["o:label"] = label
    else:
        property_value['@value'] = value['value']
    return property_value

conf_path = get_dir("config/private.yml")
config = get_config(conf_path)
dev_config = get_config(conf_path, "development")
prod_config = get_config(conf_path, "production")

omeka = OmekaAPIClient(config['omeka_server'])
omeka_auth = OmekaAPIClient(
    api_url = config['omeka_server'],
    key_identity = config['key_identity'],                        
    key_credential = config['key_credential']                        
)
parser = argparse.ArgumentParser()
parser.add_argument('-e', '--environment', required=False, default="development")
parser.add_argument('-m', '--media-skip', action='store_true',
                    help='Only ingest media not already ingested')
args = parser.parse_args()
template_number = config["resource_template"]
